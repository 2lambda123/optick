#include "Common.h"
#include "Core.h"
#include "Event.h"
#include "Event.hpp"
#include "ProfilerServer.h"
#include "EventDescriptionBoard.h"
#include "Thread.h"
#include "HPTimer.h"

//#include "Hook.h"

namespace Profiler
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static const uint32 INVALID_THREAD_ID = (uint32)-1;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ProfilerThread(PVOID)
{
	while (Server::Get().Connect())
	{
		Sleep(1000);
	}

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::CheckAndUpdateThreadID()
{
	DWORD currentThreadID = GetCurrentThreadId();
	BRO_VERIFY(currentThreadID == mainThreadID || INVALID_THREAD_ID == mainThreadID, "Can't use PROFILER_FRAME in different threads!", return);
	mainThreadID = currentThreadID;

	frame.threadUniqueID = isActive ? GetThreadUniqueID() : nullptr;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpProgress(const char* message)
{
	progressReportedLastTimestampMS = GetTimeMilliSeconds();

	OutputDataStream stream;
	stream << message;

	Server::Get().Send(DataResponse::ReportProgress, stream);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpFrames()
{
	DumpProgress("Collecting Frame Events...");
	OutputDataStream boardStream;

	static int boardID = 0;
	boardStream << ++boardID;
	boardStream << EventDescriptionBoard::Get();
	Server::Get().Send(DataResponse::FrameDescriptionBoard, boardStream);

	while (!frameList.empty())
	{
		const FrameData& frameData = frameList.front();

		OutputDataStream frameStream;
		frameStream << boardID;
		frameStream << frameData;
		Server::Get().Send(DataResponse::EventFrame, frameStream);

		frameList.pop_front();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpSamplingData()
{
	if (sampler.StopSampling())
	{
		DumpProgress("Collecting Sampling Events...");

		OutputDataStream stream;
		sampler.Serialize(stream);

		DumpProgress("Sending Message With Sampling Data...");
		Server::Get().Send(DataResponse::SamplingFrame, stream);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Core::Core() : mainThreadID(INVALID_THREAD_ID), isActive(false), progressReportedLastTimestampMS(0)
{
	workerThread = CreateThread(0, 0, ProfilerThread, this, 0, 0);
	BRO_ASSERT( workerThread, "Can't create thread!" )
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::Update()
{
	if (isActive)
	{
		frame.frameTime.Stop();
		frameList.push_back(FrameData());
		StoreFrame(frameList.back());

		if (IsTimeToReportProgress())
			DumpCapturingProgress();		
	}

	Server::Get().Update();
	CheckAndUpdateThreadID();

	if (isActive)
	{
		frame.Reset();
		frame.frameTime.Start();
	}
	else
	{
		frame.Clear();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::StoreFrame(FrameData& frameData) const
{
	// Time
	frameData.header.event = frame.frameTime;

	// Categories
	frameData.categories.reserve(frame.categoryBuffer.Size());
	frame.categoryBuffer.ForEach([&](const EventData* data) 
	{
		frameData.categories.push_back(*data);
	});
	
	// Events
	if (!frame.eventBuffer.IsEmpty())
	{
		frameData.events.resize(frame.eventBuffer.Size());
		frame.eventBuffer.ToArray(&(frameData.events[0]));
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::StartSampling()
{
	sampler.StartSampling(mainThreadID);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::Activate( bool active )
{
	isActive = active;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpCapturingProgress()
{
	std::stringstream stream;

	if (isActive)
		stream << "Capturing Frame " << frameList.size() << std::endl;

	if (sampler.IsActive())
		stream << "Sample Count " << sampler.GetCollectedCount() << std::endl;

	DumpProgress(stream.str().c_str());
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Core::IsTimeToReportProgress() const
{
	return GetTimeMilliSeconds() > progressReportedLastTimestampMS + 200;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Frame Core::frame;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Core Core::notThreadSafeInstance;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FrameHeader::FrameHeader() : frequency(Profiler::GetFrequency())
{

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
OutputDataStream& operator<<(OutputDataStream& stream, const FrameHeader& header)
{
	return stream << header.frequency << header.event;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
OutputDataStream& operator<<(OutputDataStream& stream, const FrameData& ob)
{
	return stream << ob.header << ob.categories << ob.events;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PROFILER_API Frame& GetFrame()
{
	return Core::GetFrame();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PROFILER_API void NextFrame()
{
	return Core::NextFrame();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PROFILER_API bool IsActive()
{
	return Core::Get().isActive;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}