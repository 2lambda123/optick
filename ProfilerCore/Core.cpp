#include "Common.h"
#include "Core.h"
#include "Event.h"
#include "Event.hpp"
#include "ProfilerServer.h"
#include "EventDescriptionBoard.h"
#include "Thread.h"
#include "HPTimer.h"

//#include "Hook.h"

namespace Profiler
{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static const uint32 INVALID_THREAD_ID = (uint32)-1;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD WINAPI ProfilerThread(PVOID)
{
	while (Server::Get().Connect())
	{
		Sleep(1000);
	}

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpProgress(const char* message)
{
	progressReportedLastTimestampMS = GetTimeMilliSeconds();

	OutputDataStream stream;
	stream << message;

	Server::Get().Send(DataResponse::ReportProgress, stream);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpFrames()
{
	DumpProgress("Collecting Frame Events...");
	OutputDataStream boardStream;

	static int boardID = 0;
	boardStream << ++boardID;
	boardStream << EventDescriptionBoard::Get();
	Server::Get().Send(DataResponse::FrameDescriptionBoard, boardStream);

	while (!frameList.empty())
	{
		const FrameData& frameData = frameList.front();

		OutputDataStream frameStream;
		frameStream << boardID;
		frameStream << frameData;
		Server::Get().Send(DataResponse::EventFrame, frameStream);

		frameList.pop_front();
	}

	frame.Clear();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpSamplingData()
{
	if (sampler.StopSampling())
	{
		DumpProgress("Collecting Sampling Events...");

		OutputDataStream stream;
		sampler.Serialize(stream);

		DumpProgress("Sending Message With Sampling Data...");
		Server::Get().Send(DataResponse::SamplingFrame, stream);
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Core::Core() : mainThreadID(INVALID_THREAD_ID), isActive(false), progressReportedLastTimestampMS(0)
{
	workerThread = CreateThread(0, 0, ProfilerThread, this, 0, 0);
	BRO_ASSERT( workerThread, "Can't create thread!" )
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::Update(const FrameDescription& scope)
{
	CRITICAL_SECTION(lock);

	if (GetThreadUniqueID() == frame.threadUniqueID)
	{
		frame.frameTime.Stop();
		frameList.push_back(FrameData());
		StoreFrame(frameList.back());

		if (IsTimeToReportProgress())
			DumpCapturingProgress();		
	}

	UpdateEvents(scope);

	if (GetThreadUniqueID() == frame.threadUniqueID)
	{
		frame.Reset();
		frame.frameTime.Start();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::UpdateEvents(const FrameDescription& scope)
{
	DWORD currentThreadID = GetCurrentThreadId();

	if (mainThreadID == INVALID_THREAD_ID)
		mainThreadID = currentThreadID;

	if (activeThreads.find(currentThreadID) == activeThreads.end())
		activeThreads.insert(std::make_pair(currentThreadID, &scope));

	if (currentThreadID == mainThreadID)
	{
		Server::Get().Update();
		frame.threadUniqueID = isActive ? GetThreadUniqueID() : nullptr;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::StoreFrame(FrameData& frameData) const
{
	// Time
	frameData.header.event = frame.frameTime;

	// Categories
	frameData.categories.reserve(frame.categoryBuffer.Size());
	frame.categoryBuffer.ForEach([&](const EventData* data) 
	{
		frameData.categories.push_back(*data);
	});
	
	// Events
	if (!frame.eventBuffer.IsEmpty())
	{
		frameData.events.resize(frame.eventBuffer.Size());
		frame.eventBuffer.ToArray(&(frameData.events[0]));
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::StartSampling()
{
	sampler.StartSampling(mainThreadID);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::Activate( bool active )
{
	isActive = active;

	if (active)
	{
		if (mainThreadID == INVALID_THREAD_ID && !activeThreads.empty())
		{
			mainThreadID = activeThreads.begin()->first;
		}

		SendHandshakeResponse();
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::DumpCapturingProgress()
{
	std::stringstream stream;

	if (isActive)
		stream << "Capturing Frame " << frameList.size() << std::endl;

	if (sampler.IsActive())
		stream << "Sample Count " << sampler.GetCollectedCount() << std::endl;

	DumpProgress(stream.str().c_str());
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Core::IsTimeToReportProgress() const
{
	return GetTimeMilliSeconds() > progressReportedLastTimestampMS + 200;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Core::SetWorkingThread(uint32 threadID)
{
	if (activeThreads.find(threadID) != activeThreads.end())
	{
		mainThreadID = threadID;
		return true;
	}

	return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Core::SendHandshakeResponse()
{
	OutputDataStream stream;

	stream << mainThreadID;
	stream << activeThreads.size();
	for each (auto it in activeThreads)
	{
		stream << it.first;
		stream << it.second->name;
	}

	Server::Get().Send(DataResponse::Handshake, stream);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Frame Core::frame;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Core Core::notThreadSafeInstance;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FrameHeader::FrameHeader() : frequency(Profiler::GetFrequency())
{

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
OutputDataStream& operator<<(OutputDataStream& stream, const FrameHeader& header)
{
	return stream << header.frequency << header.event;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
OutputDataStream& operator<<(OutputDataStream& stream, const FrameData& ob)
{
	return stream << ob.header << ob.categories << ob.events;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PROFILER_API Frame& GetFrame()
{
	return Core::GetFrame();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PROFILER_API void NextFrame(const FrameDescription& scope)
{
	return Core::NextFrame(scope);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PROFILER_API bool IsActive()
{
	return Core::Get().isActive;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PROFILER_API bool IsActiveCurrentThread()
{
	return Core::Get().frame.threadUniqueID == GetThreadUniqueID();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}